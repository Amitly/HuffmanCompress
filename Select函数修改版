void HuffmanTree::Select( queue<Alpha> &fir, queue<Alpha> &sec, unsigned &min_1, unsigned &min_2){
    //在函数调用前判断好fir只有0或1个元素的情况，使得进入该函数的fir至少含有两个以上结点
    //
    Alpha fir_top = fir.front();
    fir.pop();

    Alpha fir_next = fir.front();
    fir.pop();
    //将这两个元素压入sec中,在sec中记录这两个元素
    sec.push(fir_top);
    sec.push(fir_next);
    Alpha sec_top = fir_top;
    Alpha sec_next = fir_next;

    //对1、2初始化后，开始建树
        //如果fir为空，比较sec的两个元素
        if (fir.empty()){
            min_1 = hash[sec.front().ch];
            sec.pop();
            min_2 = hash[sec.front().ch];
            sec.pop();
        }
        else{
            fir_top = fir.front();
            fir.pop();
            //如果fir出一次就空，比较fir_top和sec_top即可
            if (fir.empty()){
                sec_top = sec.front();
                sec.pop();
                min_1 = fir_top.fre<sec_top.fre?hash[fir_top.ch]:hash[sec_top.ch];
                min_2 = fir_top.fre>=sec_top.fre?hash[fir_top.ch]:hash[sec_top.ch];
            }
            //如果fir有至少两个元素，sec只有一个元素，比较fir_top和sec_top,
            //如果fir_top>sec_top,则min_1为sec_top、min_2为fir_top
            //否则比较fir_top+fir_next和fir_top+sec_top大小
            else{
                sec_top = sec.front();
                sec.pop();
                if (sec.empty()){
                    if (fir_top.fre>sec_top.fre){
                        min_1 = hash[sec_top.ch];
                        min_2 = hash[fir_top.ch];
                    }
                    else{
                        if (fir_top.fre+fir_next.fre<fir_top.fre+sec_top.fre){
                            min_1 = hash[fir_top.ch];
                            min_2 = hash[fir_next.ch];
                        }
                        else{
                            min_1 = hash[fir_top.ch];
                            min_2 = hash[sec_top.ch];
                        }
                    }
                }
                //如果fir和sec都有两个及以上元素，进行各种情况比较
                else{
                    //三种情况：
                    //队列fir中的队首和第二位合并--con_1
                    //队列sec中的队首和第二位合并--con_2
                    //队列fir中的队首和sec中的队首合并--con_3
                    unsigned con_1 = fir_top.fre+fir_next.fre;
                    unsigned con_2 = fir_top.fre+sec_top.fre;
                    unsigned con_3 = sec_top.fre+sec_next.fre;

                    if (con_1<=con_2&&con_1<=con_3){
                        min_1 = hash[fir_top.ch];
                        min_2 = hash[fir_next.ch];
                    }
                    else if (con_2<=con_1&&con_2<=con_3){
                        min_1 = hash[fir_top.ch];
                        min_2 = hash[sec_top.ch];
                    }
                    else if (con_3<=con_2&&con_3<=con_1){
                        min_1 = hash[sec_top.ch];
                        min_2 = hash[sec_next.ch];
                    }
                }
            }
        }

}
